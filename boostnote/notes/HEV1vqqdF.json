{"_id":"note:HEV1vqqdF","title":"Base Color Transformation","content":"Megascansのライブラリには様々な地域でスキャンされたデータが存在します。それらを組み合わせて配置する際に、ベースカラーの色味を合わせて、ルックに統一性をもたせます。具体的には、古典的な画像の色変換の論文[Color Transfer between Images](https://www.cs.tau.ac.il/%7Eturkel/imagepapers/ColorTransfer.pdf)を用いて、スキャンされたアルベドテクスチャの色味を加工します。OpenCVやPyTorchなどのライブラリを使用した実装を参考に、HQueue上で管理しやすいようにすべてVEXで実装しました。\n\n**sRGB→Labへの変換は特殊な行列演算を行うことでできるらですが、要調査**\n\n## アルゴリズムについて\n\n色を変更したい画像をA、色を抽出したい画像をBとすると、\n\n以下の計算を各ピクセルごとに行う。\n\nInput(sRGB) → Linear化 → xyz色空間に変換 → lab色空間に変換 → labの平均と標準偏差を計算 → 式Aを適用 → xyz色空間に変換 → rgb色空間に変換\n\nこの内新しくHoudini内で実装しなければいけないのは\n\n- xyz to lab\n- 平均と標準偏差の計算\n- color transformation\n- lab to xyz\n\n## Houdiniにおける実装\n\n[Wikipedia](https://en.wikipedia.org/wiki/CIELAB_color_space#CIELAB-CIEXYZ_conversions)の3項の式を参考にVEXで実装する。\n\n```cpp\n/// colortransformation.vfl\n// XYZ -> Lab への変換\nfloat forwardtransformation(float t)\n{\n    float delta = 6.0 / 29.0;\n    float ft = t > pow(delta, 3) ? cbrt(t) : (t / ( 3 * delta * delta )) + 4.0 / 29.0;\n    return ft;\n}\n\nvector xyz2lab(vector xyz)\n{\n    float xn = 95.0489 / 100;\n    float yn = 100 / 100;\n    float zn = 108.8840 / 100;\n    float y = xyz.y / yn;\n    float x = xyz.x / xn;\n    float z = xyz.z / zn;\n\n    float l = 116 * forwardtransformation(y) - 16;\n    float a = 500 * (forwardtransformation(x) - forwardtransformation(y));\n    float b = 200 * (forwardtransformation(y) - forwardtransformation(z));\n\n    return set(l, a, b);\n}\n\n// Lab -> XYZ への変換\nfloat reversetransformation(float t)\n{\n    float delta = 6.0 / 29.0;\n    float rt = t > delta ? pow(t, 3) : 3 * delta * delta * ( t - (4.0/29.0) );\n    return rt;\n}\n\nvector lab2xyz(vector lab)\n{\n    float xn = 95.0489 / 100;\n    float yn = 100 / 100;\n    float zn = 108.8840 / 100;\n\n    float delta = 6.0 / 29.0;\n\n    float y = (lab.x + 16) / 116;\n    float x = y + (lab.y / 500);\n    float z = y - (lab.z / 200);\n\n    x = xn * reversetransformation(x);\n    y = yn * reversetransformation(y);\n    z = zn * reversetransformation(z);\n\n    return set(x, y, z);\n}\n\n// Color Transformation Algorithm\nfloat colortransformation(float x, s_mean, s_sd, t_mean, t_sd)\n{\n    x = ((x-s_mean)*(t_sd/s_sd)) + t_mean;\n    return x;\n}\n```\n### 平均と標準偏差の計算\nCOP内でループを回すと重そうなので、SOPで各ピクセルをポイントに、色をpointアトリビュートに変換して`Attribute Promote SOP`を使用し、平均と標準偏差を求める。各平均と標準偏差はCOPから参照できるようにdetailアトリビュートに保存する。\n計算した平均と標準偏差をCOPで参照し、Inline VOPで作成した関数を使用する。\n\n```cpp\n// COP/Filter Vop/Inline Vop\n# include <colortransformation.vfl>\nvector rgb = set($R, $G, $B);\nvector lab = xyz2lab(rgbtoxyz(rgb));\n\nfloat newl = colortransformation(lab.x, $s_mean.x, $s_sd.x, $t_mean.x, $t_sd.x);\nfloat newa = colortransformation(lab.y, $s_mean.y, $s_sd.y, $t_mean.y, $t_sd.y);\nfloat newb = colortransformation(lab.z, $s_mean.z, $s_sd.z, $t_mean.z, $t_sd.z);\n\nvector newcolor = xyztorgb(lab2xyz(set(newl, newa, newb)));\n\n$outR = newcolor.r;\n$outG = newcolor.g;\n$outB = newcolor.b;\n\n```\n![](bct01-kk50ysch.png)\n![](bct02-kk615h3w.png)\n\n## 注意\nこのアルゴリズムは多くの場合デティールを保持したまま色味を変えることができるが、例えば「青色の花」を「赤色の花」に変換するためには向いてない。あくまで元画像の色を指定画像の色に寄せるだけ、元画像の「青」を指定画像の「赤」に変換することは難しい。\nまた、ベースカラー等の陰影が除去された画像を陰影がついた画像に変換する場合は、コントラストが高くなってしまう場合がある。\n\n## 参考\n\n[CIELAB color space](https://en.wikipedia.org/wiki/CIELAB_color_space#RGB_and_CMYK_conversions)","tags":[],"folderPathname":"/devs","data":{},"createdAt":"2021-01-19T16:29:00.468Z","updatedAt":"2021-01-21T01:00:07.548Z","trashed":false,"_rev":"jr90OhW2X"}